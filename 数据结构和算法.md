# 数据结构和算法
## 数据结构
数据结构主要是研究程序设计问题中计算机的操作对象及它们之间的关系和操作的学科。
### 基本概念
 ***数据***  
一切可以输入计算机并能被计算机处理的都是数据，包括数字、字符、字符串、声音、图像等。  

***数据元素***  
数据元素是数据的基本单位，是数据集合的个体，在计算机程序中通常作为一个整体来进行处理。数据元素由若干个数据项组成，数据项具有原子性，是不可分割的最小单位。  

***数据对象***  
    数据对象是指性质相同的数据元素的集合，是数据的子集。  
    
***数据结构***  
  数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成，即一个数据有哪些成分数据构成，以什么方式构成，呈什么结构。  
  
  表示一组数据元素及其相互关系的数据结构有两种不同的表现形式，一种是数据结构的逻辑层面，即数据的逻辑结构；一种是数据结构的存储层面，即数据的存储结构。数据的逻辑结构按照数据元素之间的相互关系的特性来分，可以分为四种结构：集合、线性结构、树形结构和图状结构。主要的数据结构有线性表、栈、队列、树和图，其中线性表、栈和队列属于线性结构，树和图是非线性结构。
  
## 算法及性能分析
### 算法
算法是指令的集合，是为解决特定问题而规定的一系列操作。它是明确定义的可计算过程，以一个数据集合作为输入，产生一个数据集合作为输出。算法的5个特性：
* 输入
* 输出
* 可行性
* 有穷性
* 确定性
### 时间复杂度
在计算机资源中，最重要的就是时间和空间。评价一个算法的好坏，实际上就是评价算法的资源占用问题。

# 线性表
### 线性表的定义
  在数据元素的有限集合中，除第一个元素无直接前驱，最后一个元素未直接后续以外，每个数据元素有且仅有一个直接前驱和一个直接后续元素。线性表是n个**类型相同**数据元素的有限序列。  
  
  **线性表和数组的区别**：
  * 从概念上来看，线性表是一种抽象的数据类型，数组是一种具体的数据结构；
  * 线性表和数组的逻辑结构是不一样的，线性表是元素之间具有1对1的线性关系的数据元素的集合，而数组是一组数据元素到数组下标的一一映射；
  * 从物理性质上来看，数组中相邻的元素是连续的存储在内存当中的；线性表是一种抽象的数据结构，并不具有具体的物理形式，线性表需要通过其他具体物理形式的数据结构来实现；
  * 对于数组，可以利用其下标在一个操作内随机存任意位置上的元素，对于线性表，只能根据当前元素找到找到其前驱或后继，因此要存取序号为i的元素，一般不能在一个操作内实现，除非表是用数据来实现的。
  * 线性表是一种非常灵活的数据结构，线性表可以完成对表中数据元素的访问、添加、删除等操作，表的长度也可以随着数据元素的添加和删除而变化。
### 线性表的顺序存储与实现
线性表的顺序存储是用一组地址连续的存储单元依次存储线性表的数据元素。它的特定是，以数据元素在机内存储地址相邻来表示线性表中数据元素之间的逻辑关系。每一个数据元素的存储地址都和线性表的起始地址相差一个与数据元素在线性表中的序号成正比的常数。由此，只要确定来线性表的起始地址，线性表中的任何一个数据元素都可以随机存取，因此线性表的顺序存储结构是一种随机的存储结构。  
由于高级语言中的数组也具有随机存储的特性，因此在抽象数据类型的实现中都是使用数组来描述数据结构的顺序存储结构。
### 线性表的链式存储与实现
实现线性表的另一种方法是链式存储，即用指针将存储线性表中数据元素的那些单元依次串联起来。这种方法避免来在数组中使用连续的单元存储元素的缺点，因而在插入或删除运算时，不需要移动元素来腾出空间或填补空缺。而为此付出的代价是，需要在每个单元中设置指针来表示元素之间的逻辑关系，因而增加来额外的存储空间的开销。实际就是使用链表来实现线性表。
#### 单链表
  链表是一系列的存储数据元素的单元通过指针串联起来形成的，因此每个单元至少有两个域，一个域用于数据元素的存储，另一个域是指向其他单元的指针。这里具有一个数据域和多个指针域的存储单元称为结点。  
  链表的第一个结点和最后一个结点，分别称为链表的首结点和尾结点。尾结点的特征是next引用指向为空。链表中每一个结点的next引用都相当于一个指针，指向另一个结点，借助这些next引用，我们可以从链表的首结点移动到尾结点。如此定义的结点称为单链表。
#### 双向链表
  在单链表的基础上，扩展了结点结构，增加一个域，存放指向前驱的指针，这样通过一个结点的引用，不但能够访问后继结点，也可以方便地访问前驱结点。双向链表就是通过这种结点结构使用pre和next域依次串联在一起而形成的。
### 两种实现的对比
#### 基于时间的对比
线性表的操作主要有查找、插入、删除三类操作。  
对于查找操作有基于序号的查找，即存取线性表中i号数据元素。由于数组是随机存取的，在线性表的顺序存储实现中可以在O(1)的时间内完成；而链式存储中由于需要从头结点开始顺着链表才能取得，无法在常数时间内完成，因此顺序存储优于链式存储。  
对于基于元素的查找，即线性表是否包含某个元素、元素的序号是多少，这类操作线性表的顺序存储和链式存储都需要从线性表中序号为0的与元素开始依次查找，因此两种实现的性能相同。综上所诉，如果在线性表的使用中主要操作是查找，那么应选用顺序存储实现的线性表。  
对于基于数据元素的插入、删除操作，当使用数组实现相应的操作时，首先需要顺序查找到相应的元素，然后才能插入、删除，并且在插入、删除过程又要移动大量元素；相对而言链式存储的实现只需要在定位数据元素的基础上，简单的修改几个指针就能完成，因此链式存储优于顺序存储。  
对于基于序号的插入、删除操作，因为在顺序存储中平均需要移动一般的元素；而链式存储中不能直接定位，平均需要比较一半的元素才能定位，因此顺序存储和链式存储
性能相当。综上所诉，如果在线性表的使用中主要是插入、删除操作，那么选择链式存储的线性表为佳。
#### 基于空间的对比
线性表的顺序存储，其存储空间是预先静态分配好的，虽然在实现的过程中可以动态扩展数组空间，但是如果线性表的长度变化范围比较大，空间在使用过程中由于会存在大量空闲空间，使得存储空间的利用率不高。而线性表的链式存储，其结点空间是动态分配的，不会存在存储空间没有完全利用的情况。因此当线性表长度变化范围较大时，宜采用链式存储结构。  
当线性表的数据元素结构简单，并且线性表的长度变化范围不大时，由于链式存储结构使用了额外存储空间来表示数据元素之间的逻辑关系，因此针对数据域而言，指针域所占比重较大；而线性表的顺序存储结构中，没有使用额外的存储空间来表示数据元素之间的逻辑关系，尽管有一定的空闲空间没有利用，但是总体而言线性表长度变化不大，因此没有利用的空间所占比例较小，所以当线性表数据元素结构简单，长度变化不大时可以考虑采用顺序存储结构。
### 迭代器
迭代器是程序设计的一种模式，它属于设计模式中的行为模式，它的功能是提供一种方法顺序访问一个聚集对象中各个元素，而又不暴露出该对象的内部表示。  
多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂性和多样性。例如数组就是一种最基本的聚集。  
聚集对象需要提供一种方法，允许用户按照一定的顺序访问其中的所有元素。而迭代器提供了一个访问聚集对象中各个元素的统一接口，简单的说迭代器就是对遍历操作的抽象。

# 栈与队列
栈和队列是两种重要的数据结构。从栈和队列的逻辑结构上来说，它们也都是线性结构，与线性表不同的是他们所支持的基本操作是收到限制的，它们是操作受限制的线性表，是一种限定性的数据结构。
## 栈
### 定义
  栈又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一段进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作。表中进行插入、删除操作的一端称为栈顶，栈顶保存的元素称为栈顶元素。相对的，表的另一端称为栈底。由于栈的插入和删除操作只能在栈顶进行，后进栈的元素必定先出栈，所以又把堆栈称为后进先出表。
### 栈的顺序存储实现
  顺序栈是使用顺序存储结构实现的堆栈，即利用一组地址连续的存储单元依次存放堆栈中的数据元素。由于堆栈是一种特殊的线性表，因此在线性表的顺序存储结构的基础上，选择线性表的一端作为栈顶即可。根据数组操作的特点，选择数组角标大的一端，即线性表的表尾来作为栈顶，此时入栈、出栈等操作可以在O(1)时间内完成。
### 栈的链式存储实现
  链栈即采用链表作为存储结构实现的栈。当采用单链表存储线性表后，根据单链表的操作特性选择单链表的头部作为栈顶，此时入栈、出栈等操作可以在O(1)时间内完成。
## 队列
### 定义
  队列简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许表的一端进行插入，而在表的另一端进行删除。在队列中，把插入元素的一端称为队尾，删除元素的一端称为队首。向队尾插入元素称为进队或入队，新元素入队后成为新的队尾元素；从队列中删除元素称为离队或出队，元素出队后，其后继元素称为新的队首元素。由于队列的插入和删除操作分别在队尾和队首进行，每一个元素必须按照进入的次序离队，也就是说先进队的元素必然先离队，所以称队列为先进先出表。
### 队列的顺序存储实现
  在队列的顺序存储实现中，我们可以将队列当作一般的表用数组加以实现，但这样做的效果并不好。尽管我们可以用一个指针last指示队尾，使得enqueue运算可在O(1)时间内完成，但是在执行dequeue时，为了删除队首元素，必须将数组中其他所有元素都向前移动一个位置。这样当队列有n个元素时，执行dequeue就需要O(n)时间。  
  为了提高运算的效率，我们用另一种方法来表达数组中各单元的位置关系，循环数组。用循环数组实现的队列称为循环队列，我们将循环队列中从队首的元素到队尾的元素按逆时针方向存放在循环数组中一段连续的单元中。并且直接用队首指针front指向队首元素所在的单元，用队尾指针rear指向队尾元素所在单元的后一个单元。当需要将新元素入队时，可以在队尾指针指示的单元中存入新元素，并将队尾指针rear按逆时针方向移一位。出队操作也很简单，只要将队首指针front依逆时针方向移一位即可。容易看出，用循环数组实现队列可以在O(1)时间内完成enqueue和dequeue运算。
### 队列的链式存储实现
  队列的链式存储可以使用单链表来实现。为来操作实现方便，这里采用带头结点的单链表结构。根据单链表的特点，选择链表的头部作为队首，链表的尾部作为队尾。除了链表头结点需要通过一个引用来指向外，还需要一个队链表尾结点的引用，以方便队列的入队操作的实现。为此，一共设置两个指针，一个队首指针和一个队尾指针，队首指针指向队首元素的前一个结点，即始终执行链表空的头结点，队尾指针指向队列当前队尾元素所在的结点。当队列为空时，队首指针和队尾指针均指向空的头结点。
  
  
  
# 树
## 树的定义和基本术语
### 定义
  树是由一个集合以及在该集合上定义的一种关系结构。集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一个结点具有特殊地位，这个结点称为该树的根结点，或简称为树根。
  递归定义：  
  树是n个结点的有限集。它  
  1）或者是一棵空树（n=0），空树中不包含任何结点。
  2）或者是一棵非空树（n>0），此时有且仅有一个特定的称为根的结点：当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1、T2...,Tm，其中每一个本身又是一棵树，并且称为根的子树。

### 基本术语
#### 结点的层次和树的深度：  
树的结点包含一个数据元素及若干指向其子树的若干分支。结点的层次从根开始定义，层次数为0的结点是根结点，其子树的根的层次数为1。若结点在L层，其子树的根就在L+1层。对于层次为k的每一个几点c，有且仅有一个层次为k-1的结点p与之对应，p称为c的父亲或父结点。若p是c的父亲，则c称为p的孩子。父子之间的连线是的树的一条边。在树中根结点没有父亲，其余结点只有一个父亲结点，但是却可能有多个孩子，同一个结点的孩子互相称为兄弟。  
树中结点的最大层次数称为该树的深度或高度。树中的结点也有高度，其高度是以该结点为根的树的高度。

#### 结点的度与树的度
  结点拥有的子树的数目称为结点的度。度为0的结点称为叶子或终端结点。度不为0的结点称为非终端结点或分支结点。除根之外的分支结点也称为内部结点。在这里需要注意的是结点的直接前驱结点，即它的父结点不计入其度数。
  
#### 一个重要的性质
  树中的结点数等于树的边数加1，也等于所有结点的度数之和加1。  
  这是因为除根结点以外每个结点都与指向它的一条边对应，所有除根结点以外的结点数等于数中边数之和，因此数中的结点数等于树的边数加1.而边数之和就是所有结点的度数之和，因此树中的结点数也等于所有结点的度数之和加1.  
  性质说明在树中结点总数与边数的总数是相当的，基于这一个事实，在对涉及树结构的算法复杂性进行分析时，可以用结点的数目作为规模的度量。
#### 路径
  在树中k+1个结点通过k条边连接的序列{(v0,v1)、(v1,v2)、(v2,v3)...,(vk-1,vk) | k >= 0}，称为长度为k的路径。注意，此时忽略了树边的方向。  
  树中任意两个结点之间都存在唯一的路径。这意味着树既是连通的，同时又不会出现环路。从根结点开始，存在到其他任意结点的一条唯一路径，根到某个结点路径的长度，恰好是该结点的层次数。

#### 祖先、子孙、堂兄弟
  结点的祖先是从根到该结点路径上的所有结点。以某结点为根的树中的任意结点都称为该结点的子孙。父亲在同一层次的结点互为堂兄弟。

#### 有序树、m叉树、森林
  如果将树中结点的各个子树看成是从左至右是次序的，则称该树为有序树；若不考虑子树的顺序则称为无序树。对于有序树，我们可以明确定义每一个结点的第一个孩子、第二个孩子，直到最后一个孩子。若不特别指明，一般讨论的树都是有序树。  
  树中所有结点度数最大为m的有序树称为m叉树。  
  森林是m（m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。树和森林的概念相近。删去一棵树的根，就得到一个森林；反之，加上一个结点作为树的根，森林就变为一棵树。
  
## 二叉树
### 定义
  每个结点的度都不超过2的有序树，称为二叉树。与树的递归定义类似，二叉树的递归定义如下：二叉树或为一棵空树，或是一棵有一个跟结点和两棵互不相交的分别称为根的左子树和右子树的子树所组成的非空树。  
  由以上定义可知：二叉树中每个结点的孩子只能是0、1、2个，并且每个孩子都有左右之分。位于左边的孩子称为左孩子，位于右边的孩子称为右孩子；以左孩子为根的子树称为左子树，以右孩子为根的子树称为右子树。
  满二叉树：高度为k，并且有2^(k+1)指数个结点的二叉树。在满二叉树中，每层结点都达到最大数，即每层结点都是满的，因此称为满二叉树。
  完全二叉树：若在一棵满二叉树中，在最下层从最右侧起去掉相邻的若干叶子结点，得到的二叉树即为完全二叉树。  
  满二叉树必为完全二叉树，而完全二叉树不一定是满二叉树。
### 二叉树的性质
在二叉树中具有以下重要性质：
* 在二叉树的第i层上最多有2^i个结点。
* 高度为h的二叉树至多有2^(h+1)- 1个结点。
* 任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1。
* 有n个结点的完全二叉树的高度为log2n + 1.
* 含有n>=1个结点的二叉树的高度至多为n-1；高度至少为log2（n+1）。
* 如果对一个具有n个结点的完全二叉树进行编号，则对任一结点i（1<=i<=n)，有：
  （1）如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲结点是int_DOWN（ｉ / ２）。
  （2）如果2i>n，则结点i无左孩子；否则其左孩子是结点2i。
  （3）如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1.
  
### 二叉树的存储结构

#### 二叉树的顺序存储结构
  对于满二叉树和完全二叉树来说，可以将其数据元素逐层存放到一组连续的存储单元中。用一维数组来实现顺序存储结构时，将二叉树中编号为i的结点存放到数组中的第i个分量中。
  这种存储方式对于满二叉树和完全二叉树是非常合适也是非常高效的。因为满二叉树和完全二叉树采用顺序存储结构既不浪费空间，也可以根据公式很快的确定结点之间的关系。但是对于一般的二叉树而言，必须用“虚结点”将一棵二叉树补成一棵完全二叉树来存储，否则无法确定结点之间的前驱后续关系，但是这样一来就会造成空间的浪费，这是顺序存储结构的一个缺点。

#### 二叉树的链式存储结构
  设计不同的结点结构可构成不同的链式存储结构。在二叉树中每个结点都有两个孩子，则设计每个结点至少包含3个域：数据域、左孩子域和右孩子域。数据域存放数据元素，左孩子域存放指向左孩子的指针，右孩子域存放指向右孩子的指针。利用此结点结构得到的二叉树存储结构称为二叉链表。在具有n个结点的二叉链表中有n+1个空链域。
  为了方便查找父结点，可以在上述结点结构中增加一个指针域，指向结点的父结点。采用此结点结构得到的二叉树存储结构称为三叉链表。在具有n个结点的三叉链表中也有n+1个空链域。
  不同的存储结构实现二叉树操作的方法也不同。例如要求某个结点的父结点，在三叉链表中很容易实现；在二叉链表中则需要从根结点出发--查找。在实际应用中，要根据二叉树的主要操作来选择存储结构。

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
